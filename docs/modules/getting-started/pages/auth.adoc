= AeroGear Services Auth SDK

Mobile authentication SDK based on link:http://www.keycloak.org/[Keycloak] using link:http://openid.net/connect/[OpenID Connect].

Provides authentication features like access control and two factor authentication through Keycloak.

image::https://img.youtube.com/vi/MGecRG11k6E/0.jpg[title="Demo Video (https://www.youtube.com/watch?v=MGecRG11k6E&feature=youtu.be)", link="https://www.youtube.com/watch?v=MGecRG11k6E&feature=youtu.be",caption=""]

== Usage

To use the Auth SDK you'll first need to:

* Have a Keycloak instance. See <<Setting up Keycloak>>.
* Import the Core module. See link:./core.adoc[the Core documentation].
* A configuration file added to the apps assets directory. See <<Configuration file>>
* Specify the schema of the redirect url for your Android project in `android.defaultConfig.manifestPlaceholders` of the apps `build.gradle` file.
It should match the schema specified in the `Valid Redirect URL` section for the client in Keycloak.
It is recommended to use the package name of the Android app as the schema of the redirect url to avoid conflicts.
See link:../../example/src/build.gradle[the example app build.gradle file].

=== Setting up Keycloak

==== Using OpenShift

* If you do not have mobile services enabled in your openshift cluster follow this link:https://github.com/aerogear/mobile-core/blob/master/docs/walkthroughs/local-setup.adoc[Local Setup] guide.
* Navigate to your Openshift cluster and in the Service Catalog search for the Keycloak service.
* Click on the Keycloak service and you will be prompted to fill in details about your app.  For now you can leave these as they are.  Navigate through the setup and click Create.
This will provision the Keycloak service in the project you specified and create a public Client to be used with an app along with a bearer-only client.
See link:http://www.keycloak.org/docs/latest/server_admin/index.html#oidc-clients[Keycloak OIDC client documentation].

After provisioning, the Keycloak service will be available at the exposed Route. You can view this route inside your project or use the below command to get the route:
----
oc get route keycloak --template "http://{{.spec.host}} "
----
The route should look like `https://keycloak-myproject.192.168.37.1.nip.io/auth/`. +

==== Standalone

To setup standalone Keycloak follow Keycloak's guide link:/https://github.com/keycloak/keycloak/blob/master/README.md[here].

=== Adding dependency

Add dependency to your application module
----
dependencies {
    implementation 'org.aerogear:auth:5.0.0-SNAPSHOT'
}
----

=== Configuration file

A `mobile-services.json` file must exist in the apps assets directory. It should specify configuration
for Keycloak. This configuration can be generated by the link:https://github.com/aerogear/mobile-cli[AeroGear Mobile CLI].

For an example of Keycloak configuration see link:../../example/src/main/assets/mobile-services.json[example apps mobile-services.json].

The Auth SDK will use this configuration to communicate with Keycloak.

=== Initializing the SDK

`AuthService` can be retrieved using the `MobileCore#getInstance` method.

[source,java]
----
AuthService authService = mobileCore.getInstance(AuthService.class);
----

Any subsequent `MobileCore#getInstance` method will return the same instance of `AuthService`.

Before the `AuthService` can be used used `AuthService#init` must be invoked once in an app.

[source,java]
----
// Specify redirect URI. It is recommended to use the package name of your app if possible.
AuthServiceConfiguration authServiceConfig = new AuthServiceConfiguration.AuthConfigurationBuilder()
    .withRedirectUri("org.aerogear.mobile.example:/callback")
    .build();

// You only need to invoke this once, every subsequent retrieval of the AuthService will retrieve the same, already initialized, instance.
authService.init(context, authServiceConfig);
----

==== Defining Custom Scopes
Optionally, scopes can be defined for the auth request using a space as the delimiter as per https://tools.ietf.org/html/rfc6749#section-3.3[RFC-6749].
By default, the `"openid"` scope is sent if no scopes are defined.
[source,java]
----
// default is 'openid' when not defined
.withScopes("openid offline_access")
----

If `AuthService#init` is not invoked then an `IllegalStateException` will be thrown when using the
service.

=== Retrieving the current user

To retrieve the current authenticated user the `AuthService#currentUser` method can be invoked. This will be `null` if there is
no user authenticated. So it can be used to check whether to start the authentication flow or not.

[source,java]
----
// authService already initialized.
UserPrincipal currentUser = authService.currentUser();

if (currentUser != null) {
    // User is authenticated, get the users username
    String userName = currentUser.getUsername();
    // Get the users first name
    String firstName = currentUser.getFirstName();
    // Get the users last name
    String lastName = currentUser.getLastName();
    // Get the users email address
    String userEmail = currentUser.getEmail();
    // Get the access token of the authenticated user
    String accessToken = currentUser.getAccessToken();
    // Get the identity token of the authenticated user
    String identityToken = currentUser.getIdentityToken();
    // Get the refresh token of the authenticated user
    String refreshToken = currentUser.getRefreshToken();
} else {
    // User is not authenticated, start authentication flow
}
----

==== Retrieving Custom User Attributes

A walkthrough has been provided in the link:./auth-user-attributes.adoc[Keycloak Custom User Attributes] document to show how you can allow custom user attributes in Keycloak to be available in the Identity token.

You can then retrieve the custom attributes from the current user.

[source,java]
----
boolean booleanAttribute = currentUser.getCustomBooleanAttribute("booleanAttribute");
int intAttribute = currentUser.getCustomIntegerAttribute("intAttribute");
long longAttribute = currentUser.getCustomLongAttribute("longAttribute");
String stringAttribute = currentUser.getCustomStringAttribute("stringAttribute");

----

=== Authenticating

To start the authentication invoke the `AuthService#login` method.

[source,java]
----
// authService already initialized.
AuthService authService = mobileCore.getInstance(AuthService.class);

static int LOGIN_RESULT_CODE = 1;

// Build the options object and start the authentication flow. Provide an activity to handle the auth response.
DefaultAuthenticateOptions options = new DefaultAuthenticateOptions(myActivity, LOGIN_RESULT_CODE);

Callback authCallback = new Callback<UserPrincipal>() {
    @Override
    public void onSuccess(UserPrincipal principal) {
        // User authenticated in, continue on..
    }

    @Override
    public void onError(Throwable error) {
        // An error occurred during login.
    }
};

authService.login(options, authCallback);
----

Once the browser returns to the app the result can be handled. In the activity provided to the
`login` method override `onActivityResult`. This handler should always invoke
`AuthService#handleAuthResponse`, providing the `Intent`. This will exchange the temporary tokens
returned from `AuthService#login` for long-life tokens and will provide a `UserPrincipal` which can
be used to access a users details. If this is not invoked you will not have access to the
`UserPrincipal`.

More information about the user returned is available in link:../core/README.adoc[the auth module JavaDocs].

[source,java]
----
@Override
public void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == LOGIN_RESULT_CODE) {
        // The core will return the same instance of the auth service as before
        AuthService authService = mobileCore.getInstance(AuthService.class);
        authService.handleAuthResult(data);
    }
}
----

The callback provided in `AuthService#login` will be invoked.

=== Retrieving a users roles

Once a `UserPrincipal` has been retrieved the link:http://www.keycloak.org/docs/latest/server_admin/index.html#roles[roles] of the user can be listed and checked. This can
be used to perform client side access control, such as hiding UI components related to actions the
user doesn't have permissions to perform.

To list a users roles the `UserPrincipal#getRoles` method can be invoked.

Roles are divided into two types. Resource roles which belong to the client the user has
authenticated against, and Realm roles which belong to the realm the client is in.

To list a users realm roles  the `UserPrincipal#getRealmRoles` method can be invoked and 
to list a users resource roles the `UserPrincipal#getResourceRoles` can be invoked.

In order to check if a user has a specific role you can invoke the `UserPrincipal#hasResourceRole`
and `UserPrincipal#hasRealmRole` methods and provide the role name to check for.

[source,java]
----
// authService already initialized.
AuthService authService = mobileCore.getInstance(AuthService.class);
UserPrincipal currentUser = authService.currentUser();

boolean hasAdminPermissions = currentUser.hasRealmRole("user_admin");
if (hasAdminPermissions) {
    // Show some component.
}

// Check if a user has a role from a specific resource named my_resource.
boolean isModerator = currentUser.hasResourceRole("my_resource", "user_moderator");
if (isModerator) {
    // Enable some button.
}
----

=== Logging out

To logout, invoke the `AuthService#logout` method. This accepts the `UserPrincipal` that was
provided by `AuthService#handleAuthResponse` and has a callback to determine if the logout to the Keycloak or OpenID Connect server was successful.

[source,java]
----
// authService already initialized.
AuthService authService = mobileCore.getInstance(AuthService.class);
UserPrincipal currentUser = authService.currentUser();

authService.logout(currentUser, new Callback<UserPrincipal>() {
    @Override
    public void onSuccess() {
        // User Logged Out Successfully and Local Auth Tokens were Deleted
    }

    @Override
    public void onError(Throwable error) {
        // An error occurred during logout
    }
});
----

By default, the local tokens obtained during authentication are only deleted when the logout succeeded against the authentication server.
You can use the `AuthService#deleteTokens` function to delete the local authentication tokens as part of a failed logout, or for other use cases.

*Note:* To perform backchannel or federated logouts, you must enable the Backchannel Logout option for the federated identity provider. More information is available in the Keycloak documentation under  http://www.keycloak.org/docs/latest/server_admin/index.html#openid-connect-v1-0-identity-providers[OIDC Identity Providers].

=== Single Sign-on
A walkthrough on how to setup Single Sign-on across Android Applications can be seen under the link:./auth-single-sign-on.adoc[Single Sign-on Documentation].
